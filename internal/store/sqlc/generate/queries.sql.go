// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBucket = `-- name: GetBucket :one
SELECT 
    bucket_id, created_at, updated_at, key, name, cred_id, record, cipher
FROM buckets
WHERE buckets.key = $1
`

func (q *Queries) GetBucket(ctx context.Context, key string) (Bucket, error) {
	row := q.db.QueryRow(ctx, getBucket, key)
	var i Bucket
	err := row.Scan(
		&i.BucketID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Key,
		&i.Name,
		&i.CredID,
		&i.Record,
		&i.Cipher,
	)
	return i, err
}

const getBucketData = `-- name: GetBucketData :one
SELECT
    buckets.name
FROM buckets
WHERE buckets.bucket_id = $1
`

func (q *Queries) GetBucketData(ctx context.Context, bucketID int64) (string, error) {
	row := q.db.QueryRow(ctx, getBucketData, bucketID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getBucketID = `-- name: GetBucketID :one
SELECT 
    buckets.bucket_id
FROM buckets
WHERE buckets.key = $1
`

func (q *Queries) GetBucketID(ctx context.Context, key string) (int64, error) {
	row := q.db.QueryRow(ctx, getBucketID, key)
	var bucket_id int64
	err := row.Scan(&bucket_id)
	return bucket_id, err
}

const getFileID = `-- name: GetFileID :one
SELECT
    files.file_id
FROM files
WHERE files.file_uuid = $1
AND files.valid = true
AND files.buc_id = $2
`

type GetFileIDParams struct {
	FileUuid pgtype.UUID
	BucID    int64
}

func (q *Queries) GetFileID(ctx context.Context, arg GetFileIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getFileID, arg.FileUuid, arg.BucID)
	var file_id int64
	err := row.Scan(&file_id)
	return file_id, err
}

const getFileLoc = `-- name: GetFileLoc :one
SELECT
    files.file_id,
    files.base_path,
    files.data_file,
    files.meta_file,
    files.digest_file
FROM files
WHERE files.file_uuid = $1
AND files.valid = true
AND files.buc_id = $2
`

type GetFileLocParams struct {
	FileUuid pgtype.UUID
	BucID    int64
}

type GetFileLocRow struct {
	FileID     int64
	BasePath   string
	DataFile   string
	MetaFile   string
	DigestFile string
}

func (q *Queries) GetFileLoc(ctx context.Context, arg GetFileLocParams) (GetFileLocRow, error) {
	row := q.db.QueryRow(ctx, getFileLoc, arg.FileUuid, arg.BucID)
	var i GetFileLocRow
	err := row.Scan(
		&i.FileID,
		&i.BasePath,
		&i.DataFile,
		&i.MetaFile,
		&i.DigestFile,
	)
	return i, err
}

const getFileMeta = `-- name: GetFileMeta :one
SELECT
    files.data_file_size,
    files.created_at
FROM files
WHERE files.file_id = $1
`

type GetFileMetaRow struct {
	DataFileSize int64
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) GetFileMeta(ctx context.Context, fileID int64) (GetFileMetaRow, error) {
	row := q.db.QueryRow(ctx, getFileMeta, fileID)
	var i GetFileMetaRow
	err := row.Scan(&i.DataFileSize, &i.CreatedAt)
	return i, err
}

const getFiles = `-- name: GetFiles :many
SELECT
    files.created_at,
    files.file_uuid,
    files.file_info,
    files.file_info_nonce
FROM files
WHERE files.buc_id = $1 
AND files.valid = true
`

type GetFilesRow struct {
	CreatedAt     pgtype.Timestamptz
	FileUuid      pgtype.UUID
	FileInfo      string
	FileInfoNonce string
}

func (q *Queries) GetFiles(ctx context.Context, bucID int64) ([]GetFilesRow, error) {
	rows, err := q.db.Query(ctx, getFiles, bucID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesRow
	for rows.Next() {
		var i GetFilesRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.FileUuid,
			&i.FileInfo,
			&i.FileInfoNonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBucket = `-- name: InsertBucket :one
INSERT INTO buckets (key, name, cred_id, record, cipher)
VALUES ($1, $2, $3, $4, $5)
RETURNING bucket_id
`

type InsertBucketParams struct {
	Key    string
	Name   string
	CredID string
	Record string
	Cipher string
}

func (q *Queries) InsertBucket(ctx context.Context, arg InsertBucketParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertBucket,
		arg.Key,
		arg.Name,
		arg.CredID,
		arg.Record,
		arg.Cipher,
	)
	var bucket_id int64
	err := row.Scan(&bucket_id)
	return bucket_id, err
}

const insertNewFile = `-- name: InsertNewFile :exec
INSERT INTO files (buc_id, upload_id, valid, data_file, file_uuid, meta_file, digest_file, base_path, file_info, file_info_nonce, data_file_size)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type InsertNewFileParams struct {
	BucID         int64
	UploadID      string
	Valid         bool
	DataFile      string
	FileUuid      pgtype.UUID
	MetaFile      string
	DigestFile    string
	BasePath      string
	FileInfo      string
	FileInfoNonce string
	DataFileSize  int64
}

func (q *Queries) InsertNewFile(ctx context.Context, arg InsertNewFileParams) error {
	_, err := q.db.Exec(ctx, insertNewFile,
		arg.BucID,
		arg.UploadID,
		arg.Valid,
		arg.DataFile,
		arg.FileUuid,
		arg.MetaFile,
		arg.DigestFile,
		arg.BasePath,
		arg.FileInfo,
		arg.FileInfoNonce,
		arg.DataFileSize,
	)
	return err
}

const updateFileValidity = `-- name: UpdateFileValidity :exec
UPDATE files
SET 
    valid = $2
WHERE file_id = $1
`

type UpdateFileValidityParams struct {
	FileID int64
	Valid  bool
}

func (q *Queries) UpdateFileValidity(ctx context.Context, arg UpdateFileValidityParams) error {
	_, err := q.db.Exec(ctx, updateFileValidity, arg.FileID, arg.Valid)
	return err
}
